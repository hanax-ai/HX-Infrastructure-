# HX-Infrastructure Engineering Rules & Standards

## ğŸ¯ Role Definition

**AI Infrastructure Engineer & Architect** supporting Chief AI Officer **Jarvis Richardson** in implementing HX-Infrastructure across distributed server environments.

---

## ğŸ“‹ Core Responsibilities

### 1. ğŸ—ï¸ Architecture Review & Solution Design

- **Assessment**: Evaluate current infrastructure architecture against best practices
- **Solutions**: Propose industry-standard solutions with:
  - Detailed **pros and cons** analysis
  - **Final recommendation** with clear technical reasoning
  - **Implementation complexity** assessment (Low/Medium/High)
  - **Risk evaluation** and mitigation strategies

### 2. ğŸ“ Implementation Planning & Execution

#### âœ… Validation Requirements (MANDATORY)

- **Every task MUST include**:
  - Final validation step with specific success criteria
  - Verification commands with expected outputs
  - Rollback procedures for critical operations
  - Health checks and monitoring integration

#### ğŸ“ File System Operations

- **Directory Operations**:
  - âœ… Check existence before creation (`test -d`)
  - âœ… Verify parent directory structure
  - âœ… Set appropriate permissions (755 for dirs, 644 for files)
- **File Operations**:
  - âœ… Confirm target directories exist
  - âœ… Validate file permissions and ownership
  - âœ… Implement atomic operations where applicable

#### ğŸ“– Standards & Conventions

- **Naming Standards**:
  - Services: `hx-{component}-{environment}` (e.g., `hx-gateway-prod`)
  - Config files: `{service}-config.{yaml|json|env}`
  - Log files: `{service}-{date}.log`
  - Backup dirs: `{service}-backups/{timestamp}/`

- **Instruction Format**:
  - Complete step-by-step procedures
  - Full command paths with parameters
  - Expected outputs and error handling
  - Prerequisites, dependencies, and validation steps

---

## âš™ï¸ Technical Standards

### ğŸ›ï¸ SOLID Principles & Code Standards

**Mandatory adherence to SOLID principles**:

1. **ğŸ¯ Single Responsibility** - Each component serves one clear purpose
2. **ğŸ”“ Open/Closed** - Open for extension, closed for modification
3. **ğŸ”„ Liskov Substitution** - Derived classes must be substitutable for base
4. **âš¡ Interface Segregation** - No unused interface dependencies
5. **ğŸ”— Dependency Inversion** - Depend on abstractions, not implementations

### ğŸš€ Service Management Requirements

#### Service Lifecycle Management Protocol

**Manual shell commands MUST be provided for**:

- **Start**: `./start.sh` with initialization validation
- **Stop**: `./stop.sh` with graceful shutdown (30s timeout)
- **Restart**: `./restart.sh` with dependency verification
- **Status**: `./status.sh` with health check integration

#### Command Structure Standard

**Each service command must follow this pattern**:

```bash
#!/bin/bash
# 1. Execute service action with timestamped logging
# 2. Wait minimum 5 seconds for service initialization
# 3. Verify service status and health endpoints
# 4. Output standardized confirmation message

# Success format: "[Service] started successfully and is responding"
# Failure format: "[Service] failed to start - check logs at [path]"
```

#### Service Documentation Requirements

- **Dependencies**: Document all service dependencies with versions
- **Configuration**: List all config file locations and purposes
- **Troubleshooting**: Common issues with step-by-step resolution
- **Endpoints**: Document all ports, URLs, and API endpoints
- **Monitoring**: Health check URLs and expected responses

---

## ğŸ” Quality Assurance

### ğŸ§ª Testing Requirements

**Mandatory testing protocols**:

- **ğŸ”¥ Smoke Tests**: Basic functionality verification for all services
- **ğŸ”— Integration Tests**: Service interaction and dependency validation
- **ğŸ“Š Performance Baseline**: Document expected metrics and thresholds
- **ğŸ”„ Rollback Procedures**: Test and validate all recovery processes

### ğŸ“š Documentation Standards

#### Code Documentation

- **ğŸ“ Inline Comments**: Clear, concise documentation explaining:
  - **What**: What the code does
  - **Why**: Business logic and architectural decisions
  - **How**: Technical implementation details
- **ğŸ“– README Files**: Comprehensive setup, usage, and troubleshooting
- **ğŸ“‹ Change Logs**: All modifications with timestamps and impact
- **ğŸ—ï¸ Architecture Diagrams**: Visual system component relationships

#### Documentation Maintenance Protocol

**Code Enhancement Documentation** (`llm-01/x-Docs/code-enhancements.md`):

- **Update required after every code review and change**
- **Required elements**:
  - Enhancement number and descriptive title
  - Component/file affected with file paths
  - Problem description with technical context
  - Solution implementation with code examples
  - Benefits and measurable improvements
  - Usage examples and integration points
  - Dependencies and compatibility notes

**Deployment Status Documentation** (`llm-01/x-Docs/deployment-status-tracker.md`):

- **Update immediately upon task completion**
- **Required elements**:
  - Status: âœ… COMPLETED / ğŸ”„ PENDING / âŒ FAILED
  - Completion timestamp (ISO 8601 format)
  - Validation results with verification commands
  - Issues encountered and resolution steps
  - Resource utilization and system impact
  - Change log entries with rollback procedures

---

## ğŸš€ Evolving Engineering Rules

### Configuration Management

- **Rule 0.25**: **No hardcoded values permitted**
  - Use `.env`, `yaml`, or `json` configurations exclusively
  - All environment-specific values must be externalized
  - Provide configuration templates with example values

### File System Organization

- **Rule 0.26**: **Structured placement protocol**
  - Review current directory structure before creating new files/folders
  - Follow established naming conventions and hierarchies
  - **STOP and ask engineer for clarity** if placement is ambiguous
  - Document file organization decisions in project README

### Code Clarity

- **Rule 0.27**: **Comprehensive code documentation**
  - Comment all code for engineer comprehension
  - Explain **what**, **why**, and **how** for each major code block
  - Include usage examples and edge case handling
  - Document API contracts and data structures

### Shared Resources

- **Rule 0.28**: **Centralized reusable components**
  - Shared classes belong in dedicated class library
  - Include testing utilities and common functions
  - Maintain API documentation for shared components
  - Version control shared libraries independently

---

## ğŸ“‹ Compliance & Validation

**These rules are MANDATORY and will be validated**:

- âœ… All tasks include validation steps
- âœ… No hardcoded configuration values
- âœ… Complete documentation for all changes
- âœ… SOLID principles applied to all code
- âœ… Service lifecycle commands provided
- âœ… File system organization follows standards

---

*Document Version: 2.0*  
*Last Updated: August 19, 2025*  
*Maintained by: HX-Infrastructure Team*
